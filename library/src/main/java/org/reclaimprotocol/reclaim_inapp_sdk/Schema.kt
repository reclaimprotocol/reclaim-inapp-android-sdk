// Copyright 2025, Reclaim Protocol. Use of this source code is governed by a license that can be found in the LICENSE file.
// Autogenerated from Pigeon (v22.7.3), do not edit directly.
// See also: https://pub.dev/packages/pigeon
@file:Suppress("UNCHECKED_CAST", "ArrayInDataClass")

package org.reclaimprotocol.reclaim_inapp_sdk

import android.util.Log
import io.flutter.plugin.common.BasicMessageChannel
import io.flutter.plugin.common.BinaryMessenger
import io.flutter.plugin.common.EventChannel
import io.flutter.plugin.common.MessageCodec
import io.flutter.plugin.common.StandardMethodCodec
import io.flutter.plugin.common.StandardMessageCodec
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer

private fun wrapResult(result: Any?): List<Any?> {
    return listOf(result)
}

private fun wrapError(exception: Throwable): List<Any?> {
    return if (exception is FlutterError) {
        listOf(
            exception.code,
            exception.message,
            exception.details
        )
    } else {
        listOf(
            exception.javaClass.simpleName,
            exception.toString(),
            "Cause: " + exception.cause + ", Stacktrace: " + Log.getStackTraceString(exception)
        )
    }
}

private fun createConnectionError(channelName: String): FlutterError {
    return FlutterError("channel-error",  "Unable to establish connection on channel: '$channelName'.", "")}

/**
 * Error class for passing custom error details to Flutter via a thrown PlatformException.
 * @property code The error code.
 * @property message The error message.
 * @property details The error details. Must be a datatype supported by the api codec.
 */
class FlutterError (
    val code: String,
    override val message: String? = null,
    val details: Any? = null
) : Throwable()

enum class ReclaimApiVerificationExceptionType(val raw: Int) {
    UNKNOWN(0),
    SESSION_EXPIRED(1),
    VERIFICATION_DISMISSED(2),
    VERIFICATION_FAILED(3),
    VERIFICATION_CANCELLED(4);

    companion object {
        fun ofRaw(raw: Int): ReclaimApiVerificationExceptionType? {
            return values().firstOrNull { it.raw == raw }
        }
    }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class ReclaimApiVerificationRequest (
    val appId: String,
    val providerId: String,
    val secret: String,
    val signature: String,
    val timestamp: String? = null,
    val context: String,
    val sessionId: String,
    val parameters: Map<String, String>,
    val hideLanding: Boolean,
    val autoSubmit: Boolean,
    val acceptAiProviders: Boolean,
    val webhookUrl: String? = null
)
{
    companion object {
        fun fromList(pigeonVar_list: List<Any?>): ReclaimApiVerificationRequest {
            val appId = pigeonVar_list[0] as String
            val providerId = pigeonVar_list[1] as String
            val secret = pigeonVar_list[2] as String
            val signature = pigeonVar_list[3] as String
            val timestamp = pigeonVar_list[4] as String?
            val context = pigeonVar_list[5] as String
            val sessionId = pigeonVar_list[6] as String
            val parameters = pigeonVar_list[7] as Map<String, String>
            val hideLanding = pigeonVar_list[8] as Boolean
            val autoSubmit = pigeonVar_list[9] as Boolean
            val acceptAiProviders = pigeonVar_list[10] as Boolean
            val webhookUrl = pigeonVar_list[11] as String?
            return ReclaimApiVerificationRequest(appId, providerId, secret, signature, timestamp, context, sessionId, parameters, hideLanding, autoSubmit, acceptAiProviders, webhookUrl)
        }
    }
    fun toList(): List<Any?> {
        return listOf(
            appId,
            providerId,
            secret,
            signature,
            timestamp,
            context,
            sessionId,
            parameters,
            hideLanding,
            autoSubmit,
            acceptAiProviders,
            webhookUrl,
        )
    }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class ReclaimApiVerificationException (
    val message: String,
    val stackTraceAsString: String,
    val type: ReclaimApiVerificationExceptionType
)
{
    companion object {
        fun fromList(pigeonVar_list: List<Any?>): ReclaimApiVerificationException {
            val message = pigeonVar_list[0] as String
            val stackTraceAsString = pigeonVar_list[1] as String
            val type = pigeonVar_list[2] as ReclaimApiVerificationExceptionType
            return ReclaimApiVerificationException(message, stackTraceAsString, type)
        }
    }
    fun toList(): List<Any?> {
        return listOf(
            message,
            stackTraceAsString,
            type,
        )
    }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class ReclaimApiVerificationResponse (
    val sessionId: String,
    val didSubmitManualVerification: Boolean,
    val proofs: List<Map<String, Any?>>,
    val exception: ReclaimApiVerificationException? = null
)
{
    companion object {
        fun fromList(pigeonVar_list: List<Any?>): ReclaimApiVerificationResponse {
            val sessionId = pigeonVar_list[0] as String
            val didSubmitManualVerification = pigeonVar_list[1] as Boolean
            val proofs = pigeonVar_list[2] as List<Map<String, Any?>>
            val exception = pigeonVar_list[3] as ReclaimApiVerificationException?
            return ReclaimApiVerificationResponse(sessionId, didSubmitManualVerification, proofs, exception)
        }
    }
    fun toList(): List<Any?> {
        return listOf(
            sessionId,
            didSubmitManualVerification,
            proofs,
            exception,
        )
    }
}
private open class SchemaPigeonCodec : StandardMessageCodec() {
    override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
        return when (type) {
            129.toByte() -> {
                return (readValue(buffer) as Long?)?.let {
                    ReclaimApiVerificationExceptionType.ofRaw(it.toInt())
                }
            }
            130.toByte() -> {
                return (readValue(buffer) as? List<Any?>)?.let {
                    ReclaimApiVerificationRequest.fromList(it)
                }
            }
            131.toByte() -> {
                return (readValue(buffer) as? List<Any?>)?.let {
                    ReclaimApiVerificationException.fromList(it)
                }
            }
            132.toByte() -> {
                return (readValue(buffer) as? List<Any?>)?.let {
                    ReclaimApiVerificationResponse.fromList(it)
                }
            }
            else -> super.readValueOfType(type, buffer)
        }
    }
    override fun writeValue(stream: ByteArrayOutputStream, value: Any?)   {
        when (value) {
            is ReclaimApiVerificationExceptionType -> {
                stream.write(129)
                writeValue(stream, value.raw)
            }
            is ReclaimApiVerificationRequest -> {
                stream.write(130)
                writeValue(stream, value.toList())
            }
            is ReclaimApiVerificationException -> {
                stream.write(131)
                writeValue(stream, value.toList())
            }
            is ReclaimApiVerificationResponse -> {
                stream.write(132)
                writeValue(stream, value.toList())
            }
            else -> super.writeValue(stream, value)
        }
    }
}


/** Generated class from Pigeon that represents Flutter messages that can be called from Kotlin. */
class ReclaimModuleApi(private val binaryMessenger: BinaryMessenger, private val messageChannelSuffix: String = "") {
    companion object {
        /** The codec used by ReclaimModuleApi. */
        val codec: MessageCodec<Any?> by lazy {
            SchemaPigeonCodec()
        }
    }
    fun startVerification(requestArg: ReclaimApiVerificationRequest, callback: (Result<ReclaimApiVerificationResponse>) -> Unit)
    {
        val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
        val channelName = "dev.flutter.pigeon.reclaim_verifier_module.ReclaimModuleApi.startVerification$separatedMessageChannelSuffix"
        val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
        channel.send(listOf(requestArg)) {
            if (it is List<*>) {
                if (it.size > 1) {
                    callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
                } else if (it[0] == null) {
                    callback(Result.failure(FlutterError("null-error", "Flutter api returned null value for non-null return value.", "")))
                } else {
                    val output = it[0] as ReclaimApiVerificationResponse
                    callback(Result.success(output))
                }
            } else {
                callback(Result.failure(createConnectionError(channelName)))
            }
        }
    }
    fun startVerificationFromUrl(urlArg: String, callback: (Result<ReclaimApiVerificationResponse>) -> Unit)
    {
        val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
        val channelName = "dev.flutter.pigeon.reclaim_verifier_module.ReclaimModuleApi.startVerificationFromUrl$separatedMessageChannelSuffix"
        val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
        channel.send(listOf(urlArg)) {
            if (it is List<*>) {
                if (it.size > 1) {
                    callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
                } else if (it[0] == null) {
                    callback(Result.failure(FlutterError("null-error", "Flutter api returned null value for non-null return value.", "")))
                } else {
                    val output = it[0] as ReclaimApiVerificationResponse
                    callback(Result.success(output))
                }
            } else {
                callback(Result.failure(createConnectionError(channelName)))
            }
        }
    }
    fun ping(callback: (Result<Boolean>) -> Unit)
    {
        val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
        val channelName = "dev.flutter.pigeon.reclaim_verifier_module.ReclaimModuleApi.ping$separatedMessageChannelSuffix"
        val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
        channel.send(null) {
            if (it is List<*>) {
                if (it.size > 1) {
                    callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
                } else if (it[0] == null) {
                    callback(Result.failure(FlutterError("null-error", "Flutter api returned null value for non-null return value.", "")))
                } else {
                    val output = it[0] as Boolean
                    callback(Result.success(output))
                }
            } else {
                callback(Result.failure(createConnectionError(channelName)))
            }
        }
    }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface ReclaimApi {
    fun ping(callback: (Result<Boolean>) -> Unit)

    companion object {
        /** The codec used by ReclaimApi. */
        val codec: MessageCodec<Any?> by lazy {
            SchemaPigeonCodec()
        }
        /** Sets up an instance of `ReclaimApi` to handle messages through the `binaryMessenger`. */
        @JvmOverloads
        fun setUp(binaryMessenger: BinaryMessenger, api: ReclaimApi?, messageChannelSuffix: String = "") {
            val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
            run {
                val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.reclaim_verifier_module.ReclaimApi.ping$separatedMessageChannelSuffix", codec)
                if (api != null) {
                    channel.setMessageHandler { _, reply ->
                        api.ping{ result: Result<Boolean> ->
                            val error = result.exceptionOrNull()
                            if (error != null) {
                                reply.reply(wrapError(error))
                            } else {
                                val data = result.getOrNull()
                                reply.reply(wrapResult(data))
                            }
                        }
                    }
                } else {
                    channel.setMessageHandler(null)
                }
            }
        }
    }
}
